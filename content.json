{"meta":{"title":"Mr.zeng","subtitle":"曾奇的个人博客","description":"前端博客","author":"Mr.zeng","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"关于webpack的使用","date":"2018-03-08T07:20:14.367Z","updated":"2017-12-22T09:23:31.183Z","comments":true,"path":"2018/03/08/关于webpack的使用/","link":"","permalink":"http://yoursite.com/2018/03/08/关于webpack的使用/","excerpt":"","text":"关于webpack的使用标签（空格分隔）： webpack webpack is used to compile JavaScript modules 对js脚本的管理 当html页面中存在多个script标签，对脚本进行引入时，它们之间有可能会建立隐式依赖，也就是说，他们的一些方法和变量，会成为全局的属性和方法。 这样的脚本代码处理会导致如下的问题 It is not immediately apparent that the script depends on an external library. 脚本的变量和方法处于另外的脚本文件中，那么就不能就地的呈现出来，使得可读性很差 If a dependency is missing, or included in the wrong order, the application will not function properly. 当前脚本的隐式依赖的脚本文件，出现文件内容丢失，或者加载的次序存在问题，将会导致当前整个应用的无法正常工作 If a dependency is included but not used, the browser will be forced to download unnecessary code. 如果一个不需使用的脚本文件，被写入页面引用，会导致浏览器不得不去加载这个多余脚本 使用webpack管理脚本 By stating what dependencies a module needs, webpack can use this information to build a dependency graph. It then uses the graph to generate an optimized bundle where scripts will be executed in the correct order. 通过对各个模块的依赖的了解，webpack将这些依赖的信息生成了一个依赖表，根据依赖表去生成一个编译处理脚本文件，通过它来确定项目中各脚本的执行顺序。 webpack脚本管理问题的解决 使用es6语法，的import 【】 from 【】来解决。 通过将需要的变量和方法引入进来，可以更清楚的知道它们的由来，也不会造成全局的污染。 当我们将变量和方法引入进来后，就不会在受脚本的加载顺序的不当导致的无法正常工作。 采用这种脚本管理方式，能够保证当我们需要某个脚本的时候，再去加载，不会造成浏览器资源的浪费，去加载不用的脚本文件。 关于entry入口文件的使用 entry（entry point）是依赖表的起始，从入口起点进入后，webpack会找出模块和库之间的直接和间接的依赖关系 entry的使用**基本的使用** module.exports = { entry:&apos;./path/index.js&apos; }; 单个入口文件的书写 第一种： `module.exports = {entry:&apos;./path/index.js&apos; };` 第二种： `module.exports = {entry:[&apos;./path/index.js&apos;,&apos;./path/index1.js&apos;] };` 第二种写法，会创建多个主入口文件（(multi-main entry)），它们的依赖表会被webpack放置在一个块中（chunk） 单个入口文件的书写 对象语法：module.exports = { entry: { pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos; } }; 该种写法应用的扩展性最好，可以重用并且和其他的配置结合使用 关于entry point的再理解当传入的为单个入口文件时 当为string时，那么生成一个chunk 当为Arr[string]时，那么会首先生成一个包裹的chunk (main),然后再将数组元素的依赖表委托在这个主chunk中 当传入的为多个入口文件时 对象表示法 这种方法的有多个入口文件，也会生成多个打包后的文件，这样我们可以应用到多页面的应用中，他们之间是独立的依赖表，同时可以对各个页面的公共部分进行操作 关于资源管理（asset Management） webpack是默认处理脚本文件的，当它要处理其他的例如：图片， css文件时，我们需要借助于不同的挂载器来把它们处理成webpack能够处理的文件，通过相应的选项配置后，能够达到优化资源的目的 对css文件的处理到style标签中 将css文件加载到style标签中 使用cli npm i file-loader css-loader style-loader 在需要使用到css文件的地方： import ‘./src/style.css’ 到webpack的配置脚本中： `module:{ rules:[ { test:/\\.css$/, use：[ {loader:'css-loader'}, {loader:'style-loader'} ] } ] }` 将css文件独立成一个加载到style标签的href属性上 使用cli npm i css-loader style-loader file-loader 在需要使用到css文件处 import ‘./src/style.css’ 到webpack的配置脚本中： `module：{ rules：[ {test:/\\.css$/, use：[{loader:'css-loader'}, {loader:'file-loader']} ] }` 关于图片资源的处理 cli npm i file-loader image-webpack-plugin url-loader 在需要使用到的css文件处 import my from ‘./src/1.jpg’ 到webpack的配置脚本中： ` module:{ rules:[{ test:/\\.(png|jpg|gif|svg|jpeg)$/}, use:[{loader:'file-loader'}, ] }` 解决多入口文件 1、当我们的入口文件是多个时，就会产生很多个bundle文件，但是我，我们的index.html文件的脚本引入方式，是手动的，这样就导致了，entry和output的文件过多和修改所带来的脚本引入难以管理的问题 使用 html-webpack-plugin来自动的解决这类问题 clinpm i html-webpack-plugin 在webpack配置中引入插件const HtmlWebpackPlugin = require(‘html-webpack-plugin’) 在webpeak配置中： plugins:[ new HtmlWebpackPlugin({ filename:'' , template:'', inject:'' }) ] **每次打包的hash值会变化，导致历史文件会积累,使用插件，每次打包时先自动清空文件夹** 1. cli npm i clean-webpack-plugin 2. 在webpack配置中引入插件 const CleanWebpackPlugin = require('clean-webpack-plugin') 3. 在webpack配置中： plugins:[ new CleanWebpackPlugin(['dist']) ]","categories":[],"tags":[]},{"title":"","slug":"初次React-Native开发环境的搭建","date":"2018-03-08T07:20:14.298Z","updated":"2018-02-12T09:08:13.972Z","comments":true,"path":"2018/03/08/初次React-Native开发环境的搭建/","link":"","permalink":"http://yoursite.com/2018/03/08/初次React-Native开发环境的搭建/","excerpt":"","text":"初次React-Native开发环境的搭建标签（空格分隔）： 主要步骤 bug解决 1.主要安装步骤1.安装jdkjdk下载 设置jdk的环境变量 新建环境变量，JAVA_HOME= 安装目录地址 设置path路径，加入%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin 添加CLASSPATH变量,CLASSPATH = %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar CMD 中键入 java -version验证正常即可 2.安装Android-studio AS下载 3.安装sdk 打开AS 进入sdk manager 选择 sdkplatforms 和 sdk tool进行项目依赖安装 设置环境变量 新建环境变量 ANDROID_HOME = 安装路径 添加path路径tools和platform-tools路径即可 CMD 中键入 adb 验证正常即可 4.安装git和nodeJs 按照提示安装即可 5.安装react-native 打开git 键入 $ npm install -g react-native-cli react-native init demo初始化一个项目 浏览器中输入localhost:8081，查看提示是否成功 6.生成安卓文件 react-native run-android 7.安卓模拟器 使用AS打开模拟器（浏览器自带的模拟器） 本人安装了夜神模拟器，一样通过AS可以打开 2.问题及BUG1.编译过程中提示Aapt2Exception错误 在项目文件夹中，找到gradle.properties文件，添加android.enableAapt2=false 2.编译过程中提示Error:Execution failed for task &apos;:app:mergeDebugResources&apos;错误 在项目app文件中找到build.gradle文件，添加 aaptOptions.cruncherEnabled = false aaptOptions.useNewCruncher = false 3.编译过程中提示 path:ASIIC错误 更换文件的路径，路径名中不能出现中文 4.AS 提示VTX disabled in BIOS 重启电脑进行Bios界面，将virtual选项设置为enabled即可 5.夜神模拟器无法被AS识别 找到夜神安装目录，进入bin文件，在CMD 中输入 nox_adb.exe connect 127.0.0.1:62001 提示连接成功即可","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-07T15:25:53.717Z","updated":"2018-03-07T15:25:53.717Z","comments":true,"path":"2018/03/07/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}