{"meta":{"title":"Mr.zeng","subtitle":"曾奇的个人博客","description":"前端博客","author":"Mr.zeng","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"react-transition-group","slug":"react-transition-group","date":"2018-04-06T14:51:22.000Z","updated":"2018-04-06T14:52:13.032Z","comments":true,"path":"2018/04/06/react-transition-group/","link":"","permalink":"http://yoursite.com/2018/04/06/react-transition-group/","excerpt":"","text":"React-transition-group插件由社区进行维护，内容包含原有的ReactTransitionGroup和ReactCSSTransitionGroup插件，这两个插件的API能够被该插件所兼容。 ReactTransitionGroup插件是更底层的API，是基于动画的应用。 ReactCSSTransitionGroup是基于CSS动画和过渡的应用，并且它的更加易于使用。 高层API（ReactCSSTransitionGroup）ReactCSSTransitionGroup是在ReactTransitionGroup的基础上封装的更易用的高层API。并且在组件的进入和离开时，它能够更好的实现CSS 动画和过渡。（项目受 ng-animate库启发） 1、基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 @react import React, &#123; Component &#125; from &apos;react&apos;; import ReactCSSTransitionGroup from &apos;react-addons-css-transition-group&apos;; import &apos;./index.css&apos;;class App extends Component &#123; constructor(props)&#123; super(props); this.state=&#123; items:[&apos;hello&apos;,&apos;world&apos;,&apos;click&apos;,&apos;me&apos;] &#125; this.handleAdd = this.handleAdd.bind(this); &#125; handleAdd()&#123; const newItems = this.state.items.concat([ prompt(&apos;请输入内容&apos;) ]); this.setState(&#123; items:newItems &#125;) &#125; handleRemove(i)&#123; let newItems = [...this.state.items]; newItems.splice(i,1); this.setState(&#123;items:newItems&#125;); &#125; render() &#123; const items = this.state.items.map((val,i)=&gt;&#123; return( &lt; div key = &#123;val&#125; onClick = &#123;() =&gt; this.handleRemove(i) &#125; &gt; &#123;val&#125; &lt;/div&gt; ) &#125;) return ( &lt;div&gt; &lt;button onClick = &#123; this.handleAdd &#125; &gt; Add Item &lt;/button&gt; &lt;ReactCSSTransitionGroup transitionName=&quot;example&quot; transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125; &gt; &#123;items&#125; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125;export default App; CSS文件123456789101112131415@css.example-enter&#123; opacity: 0.01;&#125;.example-enter.example-enter-active&#123; opacity:1; transition: opacity 500ms ease-in&#125;.example-leave&#123; opacity: 1;&#125;.example-leave.example-leave-active&#123; opacity: .01; transition: opacity 300ms ease-in&#125; demo基于props（TransitionName）的约定，通过相应的样式定义。 2、初次渲染的动画（Appear）transitionAppear(第一次出现)动画，主要处理组件初次挂载时候的动画，它默认是不开启的。 12345678910@修改上面demo &lt;ReactCSSTransitionGroup transitionName=&quot;example&quot; transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125; transitionAppear=&#123;true&#125; transitionAppearTimeout=&#123;500&#125; &gt; &#123;items&#125; &lt;/ReactCSSTransitionGroup&gt; 12345678@修改上述demo的css.example-appear&#123; opacity: .01;&#125;.example-appear.example-appear-active&#123; opacity: 1; transition: opacity .5s ease-in&#125; 第一次渲染时，进入（enter）默认是不渲染的，通过使用Appear可以控制首次渲染时的动画。 ReactCSSTransitionGroup自定义配置1、自定义动画启动和关闭通过将各阶段的动画设置为true可以开启动画，其中enter,leave是默认开启的，appear是默认关闭的。 12345@示例enter@开启transitionEnter=&#123;true&#125;@关闭transitionLeave=&#123;false&#125; ####2、自动义 transitionName可以是字符串，也可以是一个对象。 当没有定义enterActive和leaveActive的类名的时候，它会自动依据自动的enter和leave类名加入后缀-active。 下面两种定义方式的结果相同： 12345678910111213@完全定义&lt;ReactCSSTransitionGroup transitionName&#123;&#123; enter：&apos;enter&apos;, enterActive:&apos;enterActive&apos; leave:&apos;leave&apos; leaveActive:&apos;leaveActive&apos; appear:&apos;appear&apos; appearActive:&apos;appearActive&apos; &#125;&#125;&gt;&#123;item&#125;&lt;/ReactCSSTransitionGroup&gt; 12345678910@不完全定义 &lt;ReactCSSTransitionGroup transitionName&#123;&#123; enter：&apos;enter&apos;, leave:&apos;leave&apos; appear:&apos;appear&apos; &#125;&#125;&gt;&#123;item&#125;&lt;/ReactCSSTransitionGroup&gt; ###注意事项 在组件的子组件需要动画时，需要在子组件渲染之前，ReactCSSTransitionGroup已经可以被渲染或者将Appear设置为true。 错误示例1234567891011121314151617@子组件和ReactCSSTransitionGroup是同时被渲染的render() &#123; const items = this.state.items.map((item, i) =&gt; ( &lt;div key=&#123;item&#125; onClick=&#123;() =&gt; this.handleRemove(i)&#125;&gt; &lt;CSSTransitionGroup transitionName=&quot;example&quot;&gt; &#123;item&#125; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; )); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add Item&lt;/button&gt; &#123;items&#125; &lt;/div&gt; ); &#125; 简单应用ReactCSSTransitionGroup可以渲染一个甚至0个子元素，（也就是说它可以出现和消失），这未实现轮播图提供了可能。 通过变化轮播图的元素出现和消失，可以让它形成轮播的效果。 123456789101112131415 @demo import CSSTransitionGroup from &apos;react-transition-group/CSSTransitionGroup&apos;;function ImageCarousel(props) &#123; return ( &lt;div&gt; &lt;CSSTransitionGroup transitionName=&quot;carousel&quot; transitionEnterTimeout=&#123;300&#125; transitionLeaveTimeout=&#123;300&#125;&gt; &lt;img src=&#123;props.imageSrc&#125; key=&#123;props.imageSrc&#125; /&gt; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; );&#125; 监听动画的过程当元素的进行一系列复杂的动画后，可以通过底层的ReactTransitionGroup提过的钩子API。 componentWillAppear() componentDidAppear() componentWillEnter() componentDidEnter() componentWillLeave() componentDidLeave()","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"animation","slug":"animation","permalink":"http://yoursite.com/tags/animation/"}]},{"title":"mongodb基本安装流程","slug":"mongodb基本安装流程","date":"2018-03-13T03:27:47.000Z","updated":"2018-03-13T03:35:46.728Z","comments":true,"path":"2018/03/13/mongodb基本安装流程/","link":"","permalink":"http://yoursite.com/2018/03/13/mongodb基本安装流程/","excerpt":"","text":"1、下载mongodb 下载地址 mongodb选择社区服务器 打开下载文件依照提示安装即可，一般选择custom自定义安装路径 2、新建文件 在mongod安装目录下 新建 data data/db data/log data/log/mongo.log mongo.config 3、测试连接是否正常 打开命令行工具：mongod–dbpathD:\\software\\MongoDB\\data\\db（data之前为自定义安装的路径，在本地27017端口测试） 4、将mongodb设置成系统服务 打开mongo.config文件：dbpath=D:\\software\\MongoDB\\data\\dblogpath=D:\\software\\MongoDB\\data\\log\\mongo.log（路径名依照自定义修改即可） 是管理员命令行进入到mongodb安装目录：mongod –config D:\\software\\Mongodb\\mongo.config –install –serviceName “MongoDB”（路径依上）（查看计算机服务，找到mongo即安装成功） 5、启动 打开命令行工具输入：net start MongoDB","categories":[],"tags":[{"name":"快速安装","slug":"快速安装","permalink":"http://yoursite.com/tags/快速安装/"}]},{"title":"less的基本语法","slug":"less的基本语法","date":"2018-03-09T08:16:39.000Z","updated":"2018-03-09T13:26:22.605Z","comments":true,"path":"2018/03/09/less的基本语法/","link":"","permalink":"http://yoursite.com/2018/03/09/less的基本语法/","excerpt":"","text":"基本要素 变量（variables） 混合（mixins） 参数混合（parametric mixins） 参数混合逻辑控制（mixins guards） 嵌套（nest rules） 变量的使用（varilables） 使用关键字@+自定义标识符，它通常用来代替一个重复用到的样式属性值 123456789101112@header-bg:red;@header-height:100px;div&#123; background-color: @header-bg; height: @header-height;&#125;////编译后div &#123; background-color: #ff0000; height: 100px;&#125; 混合的使用（mixins） 混合的使用，是将定义好的类名直接整体移入到调用的地方，相当于在调用处，新建一个样式块 这种方法的使用，在定义混合的时候没用加上（），所以在编译后，依旧会保留相关的类定义 123456789101112# 定义两个不带小括号混合.fl&#123; float: left &#125;.fr&#123; float: right &#125;#定义两个调用.left&#123; .fl() &#125;.right&#123; .fr() &#125;///编译后.fl &#123; float: left &#125;.fr &#123; float: right &#125;.left &#123; float: left &#125;.right &#123; float: right &#125; 下面这种，通过在定义混合的时候加上（），可以在编译后，不保留相关的类定义 12345678910 #定义两个带小括号的混合.fl()&#123; float: left &#125;.fr()&#123; float: right &#125;、 #定义两个调用.left&#123; .fl() &#125;.right&#123; .fr() &#125; #定义两个调用.left &#123; float: left &#125;.right &#123; float: right&#125; 参数混合（parametric_mixins） 参数混合的目的是：可以灵活的自定义样式值，它有点类似于变量加混合的结合用法 1234567891011121314151617181920212223242526#定义带小括号的参数混合，并在小括号中使用变量（同时可以设置参数值）.fl() &#123; float: left &#125;.fr() &#123; float: right &#125;.left &#123; .fl(); ##这里会使用默认参数 .border-radius(); &#125; .right &#123; .fr(); ##这里会使用自定义参数 .border-radius(15px) &#125; .border-radius(@r: 50%) &#123; border-radius: @r &#125; ///编译后 .left &#123; float: left; border-radius: 50%; &#125; .right &#123; float: right; border-radius: 15px; &#125; 参数逻辑条件混合(mixin_guards) 它的使用是#开头，在加上逻辑混合的写法，最后加上when(变量判断) 123456789101112131415161718192021222324252627282930313233#定义一个参数逻辑混合#fontSize(@px) when (@px=small)&#123;font-size:12px;&#125;#fontSize(@px) when (@px=middle)&#123; font-size: 24px; color: yellow;&#125;#fontSize(@px) when (@px=big)&#123; font-size: 30px; color: blue&#125;#调用.left &#123;.fl();.border-radius();#fontSize(big)&#125;.right &#123; .fr(); .border-radius(15px); #fontSize(middle)&#125;///编译后.left &#123; font-size: 30px; color: #0000ff;&#125;.right &#123; font-size: 24px; color: yellow;&#125; 嵌套规则（Nesting） 嵌套规则可以快速的定义样式的层级关系，也能明显的反映出html的文本结构 1234567891011121314151617181920212223#第一种嵌套是使用空格嵌套，它反映的是html的层级关系#定义一个嵌套.parent&#123; .son&#123; color:red; &#125; &#125; ///编译后 .parent .son&#123; color:red; &#125; #第二种嵌套是使用&amp;连接嵌套，它代表当前嵌套父级的前缀(引用父级名) #定义一个嵌套 .parent&#123; &amp;._son&#123; color:red; &#125; &#125; ///编译后 .parent_son&#123; color:red; &#125;","categories":[],"tags":[{"name":"基本语法 入门","slug":"基本语法-入门","permalink":"http://yoursite.com/tags/基本语法-入门/"}]},{"title":"react-native环境初搭建","slug":"react-native环境初搭建","date":"2018-03-08T07:25:53.000Z","updated":"2018-03-09T13:43:55.233Z","comments":true,"path":"2018/03/08/react-native环境初搭建/","link":"","permalink":"http://yoursite.com/2018/03/08/react-native环境初搭建/","excerpt":"","text":"1.主要安装步骤1.安装jdkjdk下载 设置jdk的环境变量 新建环境变量，JAVA_HOME= 安装目录地址 设置path路径，加入%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin CLASSPATH = %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar CMD 中键入 java -version验证正常即可 2.安装Android-studio AS下载 3.安装sdk 打开AS 进入sdk manager 选择 sdkplatforms 和 sdk tool进行项目依赖安装 设置环境变量 新建环境变量 ANDROID_HOME = 安装路径 添加path路径tools和platform-tools路径即可 CMD 中键入 adb 验证正常即可 4.安装git和nodeJs 按照提示安装即可 5.安装react-native 打开git 键入 $ npm install -g react-native-cli react-native init demo初始化一个项目 浏览器中输入localhost:8081，查看提示是否成功 6.生成安卓文件 react-native run-android 7.安卓模拟器 使用AS打开模拟器（浏览器自带的模拟器） 本人安装了夜神模拟器，一样通过AS可以打开 2.问题及BUG1.编译过程中提示Aapt2Exception错误 在项目文件夹中，找到gradle.properties文件，添加android.enableAapt2=false 2.编译过程中提示Error:Execution failed for task &apos;:app:mergeDebugResources&apos;错误 在项目app文件中找到build.gradle文件，添加 aaptOptions.cruncherEnabled = false aaptOptions.useNewCruncher = false 3.编译过程中提示 path:ASIIC错误 更换文件的路径，路径名中不能出现中文 4.AS 提示VTX disabled in BIOS 重启电脑进行Bios界面，将virtual选项设置为enabled即可 5.夜神模拟器无法被AS识别 找到夜神安装目录，进入bin文件，在CMD 中输入 nox_adb.exe connect 127.0.0.1:62001 提示连接成功即可","categories":[],"tags":[{"name":"sdk rn 开发环境","slug":"sdk-rn-开发环境","permalink":"http://yoursite.com/tags/sdk-rn-开发环境/"}]},{"title":"webpack的使用","slug":"webpack的使用","date":"2018-03-08T07:24:30.000Z","updated":"2018-03-09T13:44:10.415Z","comments":true,"path":"2018/03/08/webpack的使用/","link":"","permalink":"http://yoursite.com/2018/03/08/webpack的使用/","excerpt":"","text":"webpack is used to compile JavaScript modules 对js脚本的管理 当html页面中存在多个script标签，对脚本进行引入时，它们之间有可能会建立隐式依赖，也就是说，他们的一些方法和变量，会成为全局的属性和方法。 这样的脚本代码处理会导致如下的问题 It is not immediately apparent that the script depends on an external library. 脚本的变量和方法处于另外的脚本文件中，那么就不能就地的呈现出来，使得可读性很差 If a dependency is missing, or included in the wrong order, the application will not function properly. 当前脚本的隐式依赖的脚本文件，出现文件内容丢失，或者加载的次序存在问题，将会导致当前整个应用的无法正常工作 If a dependency is included but not used, the browser will be forced to download unnecessary code. 如果一个不需使用的脚本文件，被写入页面引用，会导致浏览器不得不去加载这个多余脚本 使用webpack管理脚本 By stating what dependencies a module needs, webpack can use this information to build a dependency graph. It then uses the graph to generate an optimized bundle where scripts will be executed in the correct order. 通过对各个模块的依赖的了解，webpack将这些依赖的信息生成了一个依赖表，根据依赖表去生成一个编译处理脚本文件，通过它来确定项目中各脚本的执行顺序。 webpack脚本管理问题的解决 使用es6语法，的import 【】 from 【】来解决。 通过将需要的变量和方法引入进来，可以更清楚的知道它们的由来，也不会造成全局的污染。 当我们将变量和方法引入进来后，就不会在受脚本的加载顺序的不当导致的无法正常工作。 采用这种脚本管理方式，能够保证当我们需要某个脚本的时候，再去加载，不会造成浏览器资源的浪费，去加载不用的脚本文件。 关于entry入口文件的使用 entry（entry point）是依赖表的起始，从入口起点进入后，webpack会找出模块和库之间的直接和间接的依赖关系 entry的使用**基本的使用** module.exports = { entry:&apos;./path/index.js&apos;}; 单个入口文件的书写 第一种： `module.exports = {entry:&apos;./path/index.js&apos; };` 第二种： `module.exports = {entry:[&apos;./path/index.js&apos;,&apos;./path/index1.js&apos;] };` 第二种写法，会创建多个主入口文件（(multi-main entry)），它们的依赖表会被webpack放置在一个块中（chunk） 单个入口文件的书写 对象语法：module.exports = { entry: { pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos; } }; 该种写法应用的扩展性最好，可以重用并且和其他的配置结合使用 关于entry point的再理解当传入的为单个入口文件时 当为string时，那么生成一个chunk 当为Arr[string]时，那么会首先生成一个包裹的chunk (main),然后再将数组元素的依赖表委托在这个主chunk中 当传入的为多个入口文件时 对象表示法 这种方法的有多个入口文件，也会生成多个打包后的文件，这样我们可以应用到多页面的应用中，他们之间是独立的依赖表，同时可以对各个页面的公共部分进行操作 关于资源管理（asset Management） webpack是默认处理脚本文件的，当它要处理其他的例如：图片， css文件时，我们需要借助于不同的挂载器来把它们处理成webpack能够处理的文件，通过相应的选项配置后，能够达到优化资源的目的 对css文件的处理到style标签中 将css文件加载到style标签中 使用cli npm i file-loader css-loader style-loader 在需要使用到css文件的地方： import ‘./src/style.css’ 到webpack的配置脚本中： `module:{ rules:[ { test:/\\.css$/, use：[ {loader:'css-loader'}, {loader:'style-loader'} ] } ] }` 将css文件独立成一个加载到style标签的href属性上 使用cli npm i css-loader style-loader file-loader 在需要使用到css文件处 import ‘./src/style.css’ 到webpack的配置脚本中： `module：{ rules：[ {test:/\\.css$/, use：[{loader:'css-loader'}, {loader:'file-loader']} ] }` 关于图片资源的处理 cli npm i file-loader image-webpack-plugin url-loader 在需要使用到的css文件处 import my from ‘./src/1.jpg’ 到webpack的配置脚本中： ` module:{ rules:[{ test:/\\.(png|jpg|gif|svg|jpeg)$/}, use:[{loader:'file-loader'}, ] }` 解决多入口文件 1、当我们的入口文件是多个时，就会产生很多个bundle文件，但是我，我们的index.html文件的脚本引入方式，是手动的，这样就导致了，entry和output的文件过多和修改所带来的脚本引入难以管理的问题 使用 html-webpack-plugin来自动的解决这类问题 clinpm i html-webpack-plugin 在webpack配置中引入插件const HtmlWebpackPlugin = require(‘html-webpack-plugin’) 在webpeak配置中： plugins:[ new HtmlWebpackPlugin({ filename:'' , template:'', inject:'' }) ] **每次打包的hash值会变化，导致历史文件会积累,使用插件，每次打包时先自动清空文件夹** 1. cli npm i clean-webpack-plugin 2. 在webpack配置中引入插件 const CleanWebpackPlugin = require('clean-webpack-plugin') 3. 在webpack配置中： plugins:[ new CleanWebpackPlugin(['dist']) ]","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-07T15:25:53.717Z","updated":"2018-03-07T15:25:53.717Z","comments":true,"path":"2018/03/07/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}